% -----------------------------*- LaTeX -*------------------------------
\documentclass[UTF8]{article}
% ------------------------------------------------------------------------
% Packages
% ------------------------------------------------------------------------
\usepackage{ctex} % 支持中文
\usepackage[body={7in, 9in},left=1in,right=1in]{geometry} % 改变页边距
\usepackage{amsmath} % AMS 的数学宏包
\usepackage{amsfonts} % AMS 的数学字体宏包
\usepackage{amssymb} % AMS 符号库
\usepackage{bm} % 数学公式中的黑斜体
\usepackage{amsthm} % AMS 的定理环境宏包
\usepackage{graphicx} % 插图
\usepackage{subfigure} % 插子图
\usepackage{nicefrac} % 好看的分数
\usepackage{mathrsfs} % mathscr font
\usepackage{caption} % caption
\usepackage{algorithm,algorithmicx} % 伪代码支持宏包
\usepackage[noend]{algpseudocode} % 伪代码
\usepackage{fancyhdr} % 设置页眉、页脚
\usepackage{adjustbox} % 图片尺寸自动调整
\usepackage{esint} % 积分符号
\usepackage{mathtools} % 数学宏包的重要补充
\usepackage{upgreek} % 数学环境的直立希腊字母
\usepackage{enumitem} % 使用enumitem宏包, 改变列表项的格式
\usepackage{color} % 支持彩色
\usepackage{extarrows} % 任意长度的箭头
\usepackage{tikz} % 绘图
\usepackage{forest} % 绘树
\usepackage{xcolor} % 颜色宏包
\usepackage{breqn} % 公式自动换行
\usepackage{fontsize} % 字体大小
\usepackage[framemethod=TikZ]{mdframed} % 给文字加框
\usepackage{fontspec} % 字体库
\usepackage{bigstrut} % 用于表格中的换行
\usepackage{multirow} % 表格中多行单元格合并
\usepackage{multicol} % 表格中多列单元格合并
\usepackage{longtable} % 长表格
\usepackage{rotating} % 旋转图形和表格      以上三者用于绘制三线表
\usepackage{booktabs} % 三线表宏包
\usepackage{scribe} % Scribe 模板
\usepackage{diagbox} % 表格斜线
\usepackage{listings} % 插入代码
\usetikzlibrary{automata} % 引入automata库
\usetikzlibrary{shapes,arrows,positioning,chains} % 引入positioning库
% ------------------------------------------------------------------------
% Macros
% ------------------------------------------------------------------------
%~~~~~~~~~~~~~~~
% Utility latin
%~~~~~~~~~~~~~~~
\newcommand{\ie}{\textit{i.e.}}
\newcommand{\eg}{\textit{e.g.}}
%~~~~~~~~~~~~~~~
% Environment shortcuts
%~~~~~~~~~~~~~~~
\newcommand{\balign}[1]{\ealign{\begin{align}#1\end{align}}}
\newcommand{\baligns}[1]{\ealigns{\begin{align*}#1\end{align*}}}
\newcommand{\bitemize}[1]{\eitemize{\begin{itemize}#1\end{itemize}}}
\newcommand{\benumerate}[1]{\eenumerate{\begin{enumerate}#1\end{enumerate}}}
%~~~~~~~~~~~~~~~
% Text with quads around it
%~~~~~~~~~~~~~~~
\newcommand{\qtext}[1]{\quad\text{#1}\quad}
%~~~~~~~~~~~~~~~
% Shorthand for math formatting
%~~~~~~~~~~~~~~~
\newcommand{\mbb}[1]{\mathbb{#1}}
\newcommand{\mbi}[1]{\boldsymbol{#1}} % Bold and italic (math bold italic)
\newcommand{\mbf}[1]{\mathbf{#1}}
\newcommand{\mc}[1]{\mathcal{#1}}
\newcommand{\mrm}[1]{\mathrm{#1}}
\newcommand{\tbf}[1]{\textbf{#1}}
\newcommand{\tsc}[1]{\textsc{#1}}
%\def\\langle {{\langle }}
%\def\\rangle {{\rangle }}
\newcommand{\sT}{\sf T}
\newcommand{\grad}{\nabla}
\newcommand{\Proj}{\Pi}
%~~~~~~~~~~~~~~~
% Common sets 定义数集符号
%~~~~~~~~~~~~~~~
\newcommand{\R}{\mathbb{R}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\reals}{\mathbb{R}} % Real number symbol
\newcommand{\integers}{\mathbb{Z}} % Integer symbol
\newcommand{\rationals}{\mathbb{Q}} % Rational numbers
\newcommand{\naturals}{\mathbb{N}} % Natural numbers
\newcommand{\complex}{\mathbb{C}} % Complex numbers
%~~~~~~~~~~~~~~~
% Common functions
%~~~~~~~~~~~~~~~
\renewcommand{\exp}[1]{\operatorname{exp}\left(#1\right)} % Exponential
\newcommand{\indic}[1]{\mbb{I}\left(#1\right)} % Indicator function
\newcommand{\indicsub}[2]{\mbb{I}_{#2}\left(#1\right)} % Indicator function
\newcommand{\argmax}{\mathop\mathrm{arg\, max}} % Defining math symbols
\newcommand{\argmin}{\mathop\mathrm{arg\, min}}
\renewcommand{\arccos}{\mathop\mathrm{arccos}}
\newcommand{\dom}{\mathop\mathrm{dom}} % Domain
\newcommand{\range}{\mathop\mathrm{range}} % Range
\newcommand{\diag}{\mathop\mathrm{diag}}
\newcommand{\tr}{\mathop\mathrm{tr}}
\newcommand{\abs}{\mathop\mathrm{abs}}
\newcommand{\card}{\mathop\mathrm{card}}
\newcommand{\sign}{\mathop\mathrm{sign}}
\newcommand{\prox}{\mathrm{prox}} % prox
\newcommand{\rank}[1]{\mathrm{rank}(#1)}
\newcommand{\supp}[1]{\mathrm{supp}(#1)}
\newcommand{\norm}[1]{\lVert#1\rVert}
%~~~~~~~~~~~~~~~
% Common probability symbols
%~~~~~~~~~~~~~~~
\newcommand{\family}{\mathcal{P}} % probability family / statistical model
\newcommand{\iid}{\stackrel{\mathrm{iid}}{\sim}}
\newcommand{\ind}{\stackrel{\mathrm{ind}}{\sim}}
\newcommand{\E}{\mathbb{E}} % Expectation symbol
\newcommand{\Earg}[1]{\E\left[#1\right]}
\newcommand{\Esubarg}[2]{\E_{#1}\left[#2\right]}
\renewcommand{\P}{\mathbb{P}} % Probability symbol
\newcommand{\Parg}[1]{\P\left(#1\right)}
\newcommand{\Psubarg}[2]{\P_{#1}\left[#2\right]}
%\newcommand{\Cov}{\mrm{Cov}} % Covariance symbol
%\newcommand{\Covarg}[1]{\Cov\left[#1\right]}
%\newcommand{\Covsubarg}[2]{\Cov_{#1}\left[#2\right]}
%\newcommand{\model}{\mathcal{P}} % probability family / statistical model
%~~~~~~~~~~~~~~~
% Distributions
%~~~~~~~~~~~~~~~
%\newcommand{\Gsn}{\mathcal{N}}
%\newcommand{\Ber}{\textnormal{Ber}}
%\newcommand{\Bin}{\textnormal{Bin}}
%\newcommand{\Unif}{\textnormal{Unif}}
%\newcommand{\Mult}{\textnormal{Mult}}
%\newcommand{\NegMult}{\textnormal{NegMult}}
%\newcommand{\Dir}{\textnormal{Dir}}
%\newcommand{\Bet}{\textnormal{Beta}}
%\newcommand{\Gam}{\textnormal{Gamma}}
%\newcommand{\Poi}{\textnormal{Poi}}
%\newcommand{\HypGeo}{\textnormal{HypGeo}}
%\newcommand{\GEM}{\textnormal{GEM}}
%\newcommand{\BP}{\textnormal{BP}}
%\newcommand{\DP}{\textnormal{DP}}
%\newcommand{\BeP}{\textnormal{BeP}}
%\newcommand{\Exp}{\textnormal{Exp}}
%~~~~~~~~~~~~~~~
% Theorem-like environments
%~~~~~~~~~~~~~~~
%\theoremstyle{definition}
%\newtheorem{definition}{Definition}
%\newtheorem{example}{Example}
%\newtheorem{problem}{Problem}
%\newtheorem{lemma}{Lemma}
%~~~~~~~~~~~~~~~
% 组合数学的模板和作业里用到的一些宏包和自定义命令
%~~~~~~~~~~~~~~~
\renewcommand{\emph}[1]{\begin{kaishu}#1\end{kaishu}}
\newcommand{\falfac}[1]{^{\underline{#1}}}
\newcommand{\binomfrac}[2]{\frac{#1^{\underline{#2}}}{#2!}}
\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\suminfty}[2]{\sum_{#1=#2}^{\infty}}
\newcommand{\suminftyk}[0]{\sum_{k=0}^{\infty}}
\newcommand{\sumint}[3]{\sum_{#1=#2}^{#3}}
\newcommand{\sumintk}[2]{\sum_{k=#1}^{#2}}
\newcommand{\suminti}[2]{\sum_{i=#1}^{#2}}
%~~~~~~~~~~~~~~~
% 定义新命令
%~~~~~~~~~~~~~~~
\newcommand*{\unit}[1]{\mathop{}\!\mathrm{#1}}
\newcommand*{\dif}{\mathop{}\!\mathrm{d}}%微分算子 d
\newcommand*{\pdif}{\mathop{}\!\partial}%偏微分算子
\newcommand*{\cdif}{\mathop{}\!\nabla}%协变导数、nabla 算子
\newcommand*{\laplace}{\mathop{}\!\Delta}%laplace 算子
\newcommand*{\deri}[1]{\mathrm{d} #1}
\newcommand*{\deriv}[2]{\frac{\mathrm{d} #1}{\mathrm{d} {#2}}}
\newcommand*{\derivh}[3]{\frac{\mathrm{d}^{#1} #2}{\mathrm{d} {#3^{#1}}}}
\newcommand*{\pderiv}[2]{\frac{\partial #1}{\partial {#2}}}
\newcommand*{\pderivh}[3]{\frac{\partial^{#1} #2}{\partial {#3^{#1}}}}
\newcommand*{\dderiv}[2]{\dfrac{\mathrm{d} #1}{\mathrm{d} {#2}}}
\newcommand*{\dderivh}[3]{\dfrac{\mathrm{d}^{#1} #2}{\mathrm{d} {#3^{#1}}}}
\newcommand*{\dpderiv}[2]{\dfrac{\partial #1}{\partial {#2}}}
\newcommand*{\dpderivh}[3]{\dfrac{\partial^{#1} #2}{\partial {#3^{#1}}}}
\newcommand{\me}[1]{\mathrm{e}^{#1}}%e 指数
\newcommand{\mi}{\mathrm{i}}%虚数单位
%\newcommand{\mc}{\mathrm{c}}%光速 定义与mathcal冲突
\newcommand{\red}[1]{\textcolor{red}{#1}}
\newcommand{\blue}[1]{\textcolor{blue}{#1}}
%\newcommand{\Rome}[1]{\setcounter{rome}{#1}\Roman{rome}}
%~~~~~~~~~~~~~~~
% 公式环境中箭头符号的简写
%~~~~~~~~~~~~~~~
\newcommand{\ra}{\rightarrow}
\newcommand{\Ra}{\Rightarrow}
\newcommand{\la}{\leftarrow}
\newcommand{\La}{\Leftarrow}
\newcommand{\lra}{\leftrightarrow}
\newcommand{\Lra}{\Leftrightarrow}
\newcommand{\lgla}{\longleftarrow}
\newcommand{\Lgla}{\Longleftarrow}
\newcommand{\lgra}{\longrightarrow}
\newcommand{\Lgra}{\Longrightarrow}
\newcommand{\lglra}{\longleftrightarrow}
\newcommand{\Lglra}{\Longleftrightarrow}
%~~~~~~~~~~~~~~~
% 一些数学的环境设置
%~~~~~~~~~~~~~~~
%\newcounter{counter_exm}\setcounter{counter_exm}{1}
%\newcounter{counter_prb}\setcounter{counter_prb}{1}
%\newcounter{counter_thm}\setcounter{counter_thm}{1}
%\newcounter{counter_lma}\setcounter{counter_lma}{1}
%\newcounter{counter_dft}\setcounter{counter_dft}{1}
%\newcounter{counter_clm}\setcounter{counter_clm}{1}
%\newcounter{counter_cly}\setcounter{counter_cly}{1}
\newtheorem{theorem}{{\hskip 1.7em \bf 定理}}
\newtheorem{lemma}[theorem]{\hskip 1.7em 引理}
\newtheorem{proposition}[theorem]{\hskip 1.7em 命题}
\newtheorem{claim}[theorem]{\hskip 1.7em 断言}
\newtheorem{corollary}[theorem]{\hskip 1.7em 推论}
% \newcommand{\problem}[1]{{\setlength{\parskip}{10pt}\noindent \bf{#1}}}
\newenvironment{solution}{{\noindent \bf 解 \quad}}{}
\newenvironment{remark}{{\noindent \bf 注 \quad}}{}
\newenvironment{definition}{{\noindent \bf 定义 \quad}}{}
\renewenvironment{proof}{{\setlength{\parskip}{7pt}\noindent\hskip 2em \bf 证明 \quad}}{\hfill$\qed$\par}
\newenvironment{example}{{\noindent\bf 例 \quad}}{\hfill$\qed$\par}
%\newenvironment{concept}[1]{{\bf #1\quad} \begin{kaishu}} {\end{kaishu}\par}
%~~~~~~~~~~~~~~~
% 本.tex文档中特殊定义命令
%~~~~~~~~~~~~~~~
\newcommand{\lno}[1]{\overline{#1}}
\newcommand{\NP}{\mathrm{NP}}
\newcommand{\coNP}{\mathrm{coNP}}
% \newcommand{\ISO}{\mathrm{ISO}}
\newcommand{\SAT}{\mathrm{SAT}}
\newcommand{\USAT}{\mathrm{USAT}}
% \newcommand{\threeSAT}{\mathrm{3\text{-}SAT}}
\renewcommand{\P}{\mathrm{P}}
% \mathchardef\mhyphen="2D
% \newcommand{\CNF}{\mathrm{CNF}}
% \newcommand{\DNF}{\mathrm{DNF}}
% \newcommand{\SetSp}{\mathrm{SET\text{-}SPLITTING}}
% \newcommand{\PUZZLE}{\mathrm{PUZZLE}}
% \newcommand{\SPATH}{\mathrm{SPATH}}
% \newcommand{\LPATH}{\mathrm{LPATH}}
% \newcommand{\UHAMPATH}{\mathrm{UHAMPATH}}
\newcommand{\SPACE}{\mathrm{SPACE}}
\newcommand{\NSPACE}{\mathrm{NSPACE}}
\newcommand{\PSPACE}{\mathrm{PSPACE}}
\newcommand{\NPSPACE}{\mathrm{NPSPACE}}
\newcommand{\DFA}{\mathrm{DFA}}
\newcommand{\NFA}{\mathrm{NFA}}
\newcommand{\TQBF}{\mathrm{TQBF}}
% \newcommand{\L}{\mathrm{L}}
\renewcommand{\O}{\mathrm{O}}
\newcommand{\NL}{\mathrm{NL}}
\newcommand{\coNL}{\mathrm{coNL}}
\newcommand{\LADDER}{\mathrm{LADDER_{DFA}}}
\newcommand{\hd}{\mathrm{\text{-}hard}}
\newcommand{\ADD}{\mathrm{ADD}}
\newcommand{\STCN}{\mathrm{STRONGLY\text{-}CONNECTED}}
\newcommand{\PATH}{\mathrm{PATH}}
\newcommand{\A}{\mathrm{A}}
%使用align环境公式换页
\allowdisplaybreaks[4]

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstset{
  frame=tb,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  framerule=1pt,
  rulecolor=\color{gray!35},
  backgroundcolor=\color{gray!5},
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
}

\setmainfont{Times New Roman}
\setsansfont{Times New Roman}
\setmonofont{Menlo}
\setCJKmainfont{STHeiti}
\setCJKsansfont{STSong}
\setCJKmonofont{STFangsong}
\punctstyle{kaiming}

\begin{document}

\pagestyle{fancy}
\lhead{\emph{操作系统实例分析}}
\chead{\emph{中国科学院大学}}
\rhead{\emph{张家玮、罗彦博、赵逸鸣}}

\begin{center}
    {\LARGE \bf 实例分析1：进程}
\end{center}

\section{第零部分：初识xv6}

\subsubsection{基础题}

\begin{enumerate}
    \item 安装相应工具链，在 qemu 中运行 xv6。并在操作系统中运行 ls 命令。
    \item 阅读 ls.c 。请回答: 代码中的 read() 函数和 printf() 函数哪个是系统调用?它们的函数声明在哪里，函数定义在哪里?
    
    read()是系统调用，函数声明在user/user.h中，定义在user.pl中，其中有一段内联汇编代码，将sys\_read()系统调用的系统调用号送给a7，然后调用ecall指令，进入内核态执行系统调用。printf()不是系统调用，函数声明在user/user.h中，定义在user/printf.c中。
    \item 阅读 usys.S ，查阅 RISC-V 相关知识，请问 ecall 指令的功能是什么?(如果找不到usys.S ，请自我反思一下，不要阅读静态代码)
    
    ecall指令是RISC-V中的一个特权指令，用于从用户态切换到内核态，触发异常处理程序，执行系统调用。a7寄存器中存放系统调用号，a0-a6寄存器中存放系统调用的参数。
\end{enumerate}

\subsubsection{进阶题}

\noindent
阅读 xv6 项目相关的 Makefile 文件、 mkfs.c 文件和链接器相关文件，分析 xv6 把内核和 用戶态程序编译链接的整个过程。并思考一个问题，xv6运行的时候，ls 可以看到里面有一 个 README 文件，我在 xv6 操作系统把它删除，为什么本地项目的 README 文件仍存在 (反之如此)?

\vspace{1em}

xv6的Makefile文件中定义了一系列的变量，包括编译器、编译选项、链接器等。在编译xv6时，首先编译bootblock，然后编译kernel，最后编译用户态程序。编译用户态程序时，首先编译mkfs，然后编译init，最后编译其他用户态程序。编译用户态程序时，需要链接器将用户态程序和内核链接在一起，生成ELF文件。在编译xv6时，会生成一个文件系统的镜像文件，包括bootblock、kernel、用户态程序等。在运行xv6时，会将这个镜像文件加载到内存中，然后运行bootblock，bootblock会加载kernel，kernel会加载用户态程序。因此，xv6运行的时候，ls可以看到里面有一个README文件，如果在xv6操作系统中删除README文件，本地项目的README文件仍然存在，是因为本地项目的README文件和xv6的文件系统镜像文件是两个不同的文件，删除xv6的文件系统镜像文件中的README文件并不会影响本地项目的README文件。

\section{第四部分: 进程的运行}

\subsubsection{基础题}

\begin{enumerate}
    \item proc.c 中 uchar initcode[] 的诡异的二进制数据的含义是什么?为什么 userinit() 函数要把它拷⻉到 usr page 中?它和 user/initCode.S 有什么联系?
    
    \begin{lstlisting}[language=C]
        // a user program that calls exec("/init")
        // assembled from ../user/initcode.S
        // od -t xC ../user/initcode
        uchar initcode[] = {
          0x17, 0x05, 0x00, 0x00, 0x13, 0x05, 0x45, 0x02,
          0x97, 0x05, 0x00, 0x00, 0x93, 0x85, 0x35, 0x02,
          0x93, 0x08, 0x70, 0x00, 0x73, 0x00, 0x00, 0x00,
          0x93, 0x08, 0x20, 0x00, 0x73, 0x00, 0x00, 0x00,
          0xef, 0xf0, 0x9f, 0xff, 0x2f, 0x69, 0x6e, 0x69,
          0x74, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00
        };        
    \end{lstlisting}
    
    这一些二进制数据实际上拼起来是一个用户程序，调用exec("/init")。
    
    userinit()函数将这个用户程序拷贝到用户态的内存中，然后调用exec()函数执行这个用户程序，是为了在系统启动时执行一个初始的用户程序，从而进入用户模式。
    
    下面展示出userinit()函数的代码：

    \begin{lstlisting}[language=C]
        // Set up first user process.
        void
        userinit(void)
        {
          struct proc *p;
        
          p = allocproc();
          initproc = p;
          
          // allocate one user page and copy initcode's instructions
          // and data into it.
          uvmfirst(p->pagetable, initcode, sizeof(initcode));
          p->sz = PGSIZE;
        
          // prepare for the very first "return" from kernel to user.
          p->trapframe->epc = 0;      // user program counter
          p->trapframe->sp = PGSIZE;  // user stack pointer
        
          safestrcpy(p->name, "initcode", sizeof(p->name));
          p->cwd = namei("/");
        
          p->state = RUNNABLE;
        
          release(&p->lock);
        }
    \end{lstlisting}

    initcode[]和user/initCode.S是一样的，都是一个用户程序，调用exec("/init")。

    \item 第一个进程启动后在用户态执行的程序是什么?这个程序执行了哪个系统调用?
    
    第一个进程启动后在用户态执行的程序是user/init.c，代码如下：

    \begin{lstlisting}[language=C]
        // init: The initial user-level program

        #include "kernel/types.h"
        #include "kernel/stat.h"
        #include "kernel/spinlock.h"
        #include "kernel/sleeplock.h"
        #include "kernel/fs.h"
        #include "kernel/file.h"
        #include "user/user.h"
        #include "kernel/fcntl.h"
        
        char *argv[] = { "sh", 0 };
        
        int
        main(void)
        {
          int pid, wpid;
        
          if(open("console", O_RDWR) < 0){
            mknod("console", CONSOLE, 0);
            open("console", O_RDWR);
          }
          dup(0);  // stdout
          dup(0);  // stderr
        
          for(;;){
            printf("init: starting sh\n");
            pid = fork();
            if(pid < 0){
              printf("init: fork failed\n");
              exit(1);
            }
            if(pid == 0){
              exec("sh", argv);
              printf("init: exec sh failed\n");
              exit(1);
            }
        
            for(;;){
              // this call to wait() returns if the shell exits,
              // or if a parentless process exits.
              wpid = wait((int *) 0);
              if(wpid == pid){
                // the shell exited; restart it.
                break;
              } else if(wpid < 0){
                printf("init: wait returned an error\n");
                exit(1);
              } else {
                // it was a parentless process; do nothing.
              }
            }
          }
        }
    \end{lstlisting}
    
    这个程序执行了open()、mknod()、dup()、fork()、exec()、wait()、exit()等系统调用。

    open() 系统调用用于打开文件，mknod() 系统调用用于创建设备文件，dup() 系统调用用于复制文件描述符，fork() 系统调用用于创建子进程，exec() 系统调用用于执行程序，wait() 系统调用用于等待子进程退出，exit() 系统调用用于退出进程。

    上面的程序是一个无限循环，不断创建子进程执行sh程序，如果sh程序退出，则重新创建一个sh进程。

    \item 在 exec.c 的 exec() 中，用到的 struct elfhdr 数据结构，其中 magic ， phnum，phoff 等字段的作用是什么?以及 struct proghdr 的数据结构，其中 vaddr，memsz，filesz 等字段的作用是什么?
    
    struct elfhdr 数据结构是ELF文件头，用于描述ELF文件的基本信息，magic字段用于标识ELF文件，phnum字段表示ELF文件中的程序头的数量，phoff字段表示ELF文件中的程序头表的偏移量。

    struct proghdr 数据结构是程序头，用于描述ELF文件中的程序段的信息，vaddr字段表示程序段的虚拟地址，memsz字段表示程序段在内存中的大小，filesz字段表示程序段在文件中的大小。

    \item 在 exec() 中，如何确定并设置待运行的程序的 PC 值和栈指针?
    
    exec() 函数会读取 ELF 文件头，以获取程序入口点的地址，然后将这个地址设置为新进程的 PC 值。

    在加载完程序段后，exec() 函数会为用户栈分配内存，并将命令行参数拷贝到栈中。然后，计算并设置栈指针（SP）。计算过程如下：

    \begin{lstlisting}[language=C]
        // Push argument strings, prepare rest of stack in ustack.
        for(argc = 0; argv[argc]; argc++) {
          if(argc >= MAXARG)
            goto bad;
          sp -= strlen(argv[argc]) + 1;
          sp -= sp % 16; // riscv sp must be 16-byte aligned
          if(sp < stackbase)
            goto bad;
          if(copyout(pagetable, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
            goto bad;
          ustack[argc] = sp;
        }
        ustack[argc] = 0;
        
        // push the array of argv[] pointers.
        sp -= (argc+1) * sizeof(uint64);
        sp -= sp % 16;
        if(sp < stackbase)
          goto bad;
        if(copyout(pagetable, sp, (char *)ustack, (argc+1)*sizeof(uint64)) < 0)
          goto bad;
    \end{lstlisting}

    \item exec() 执行完以后，返回的地址是什么?为什么?
    
    exec() 函数执行完以后，返回的地址是新程序的入口点地址elf.entry，因为它会用新程序替换当前进程的地址空间，并开始执行新程序。
    
    \item 在user/init.c 中调用了 fork() 函数创建子进程。请问在调用 fork() 系统调用后，是父
    进程先返回还是子进程先返回?

    子进程先返回，因为父进程会wait()子进程，等待子进程退出。

    \item 在调用 fork() 系统调用后，子进程是如何从 RUNNABLE 转换到 RUNNING 状态的?
    
    实际上，子进程是由操作系统调度器调度的，当子进程创建后，fork()函数会将子进程的状态设置为RUNNABLE，然后由操作系统调度器调度，将子进程从RUNNABLE状态转换到RUNNING状态。

    \item 对于父进程和子进程， fork() 返回的 pid 相同么?为什么?
    
    父进程和子进程是两个不同的进程，pid当然不同。

    \item wait 系统调用的功能?
    
    wait()系统调用用于等待子进程退出，如果子进程已经退出，则wait()会立即返回，否则wait()会阻塞当前进程，直到子进程退出。
\end{enumerate}

\subsubsection{进阶题}

\noindent
请结合代码详细分析 Linux 中 elf 文件格式(利用 readelf 命令)，以及链接和加载的机制。

\vspace{1em}

在kernel/elf.h中定义了ELF文件头的数据结构elfhdr和程序头的数据结构proghdr，代码如下：

\begin{lstlisting}[language=C]
    // Format of an ELF executable file

    #define ELF_MAGIC 0x464C457FU  // "\x7FELF" in little endian
    
    // File header
    struct elfhdr {
      uint magic;  // must equal ELF_MAGIC
      uchar elf[12];
      ushort type;
      ushort machine;
      uint version;
      uint64 entry;
      uint64 phoff;
      uint64 shoff;
      uint flags;
      ushort ehsize;
      ushort phentsize;
      ushort phnum;
      ushort shentsize;
      ushort shnum;
      ushort shstrndx;
    };
    
    // Program section header
    struct proghdr {
      uint32 type;
      uint32 flags;
      uint64 off;
      uint64 vaddr;
      uint64 paddr;
      uint64 filesz;
      uint64 memsz;
      uint64 align;
    };
    
    // Values for Proghdr type
    #define ELF_PROG_LOAD           1
    
    // Flag bits for Proghdr flags
    #define ELF_PROG_FLAG_EXEC      1
    #define ELF_PROG_FLAG_WRITE     2
    #define ELF_PROG_FLAG_READ      4
\end{lstlisting}

elf文件格式的示意图如下所示：

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{elfformat2.jpg}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{elfformat1.png}
    \caption{ELF文件格式}
\end{figure}

链接是将多个目标文件和库文件组合成一个可执行文件的过程。链接可以分为两种类型：静态链接和动态链接。

静态链接（Static Linking）：在编译时，将所有需要的库函数和目标文件组合到一个单一的可执行文件中。

动态链接（Dynamic Linking）：在运行时，将库函数动态加载到内存中，并链接到可执行文件。

加载是加载器将可执行文件从磁盘加载到内存中，并准备执行的过程。包括以下步骤：

读取可执行文件头：加载器首先读取可执行文件的头部信息，以确定文件格式、入口点、段信息等。
分配内存：根据可执行文件的段信息，加载器在内存中分配相应的空间，包括代码段、数据段、堆和栈。
加载段：将可执行文件的各个段（如代码段、数据段）加载到分配的内存区域中。
动态链接（如果使用动态链接）：加载器在运行时加载动态库，并解析符号表，将库函数链接到可执行文件中。
设置入口点：加载器将程序计数器（PC）设置为可执行文件的入口点地址。
开始执行：加载器将控制权交给可执行文件，开始执行程序。
\end{document}